# Functions for building JSON Schemas from documentation objects
# and data frames

# JSON Schema builders -------

#' Create JSON Schemas from R data frames and variable documentation objects.
#'
#' @description
#' `build_schema()` methods create JSON Schemas for R data frames, or variable
#' documentation objects generated by the user per hand or with
#' \code{\link{create_doc}}.
#'
#' @details
#' If `as_schema = TRUE`, the function returns a \code{\link{schema}} class
#' object generated from the JSON Schema string. Otherwise a plain string of
#' class \code{\link{schema_string}} is returned.
#' Those objects can be saved as JSON files on the disc with
#' \code{\link{write_schema}}.
#'
#' Please note, that the output of `build_schema()` function provides only the
#' core validation functionality and does not allow for generation dependent
#' requirements or dependent schemas (sub-schemas) - because this information
#' cannot be extracted from a plain data frame.
#' Such extra validation statements may be specified via `tail_statement`
#' argument.
#'
#' By specifying `description_extras`, the user may include additional columns
#' from the documentation in the JSON Schema.
#' If `extras_keywords = FALSE`, this extra portion information will be pasted
#' with the `description` keyword with the `|` separator.
#' If `extras_keywords = TRUE`, the additional columns, if not empty, will be
#' included in the schema as additional keywords under `property` key of the
#' variables.
#' Please note that such custom keywords may not be automatically recognized
#' by standard JSON Schema validators.
#' See: https://json-schema.org/understanding-json-schema/reference/schema#guidelines
#'
#'
#' @return a string of class \code{\link{schema_string}} with the JSON Schema
#' structure (`as_schema = FALSE`) or a \code{\link{schema}} class object
#' (`as_schema = TRUE`).
#'
#' @examples
#' car_documentation <- create_doc(my_cars)
#' build_schema(car_documentation)
#'
#' @param x a data frame or a documentation object.
#' @param schema_key value of the `$schema` keyword in the JSON Schema header;
#' usually refers to the validation schema used later by a validator function.
#' @param id_key value of the `$id` keyword in the JSON Schema header;
#' usually a project or table identifier.
#' @param title_key value of the `title` keyword in the JSON Schema header; usually
#' a project or table title
#' @param description_key value of the `description` keyword in the JSON Schema
#' header; usually a short description of a table or a project
#' @param description_extras names of the documentation columns to be included
#' in the variable description (`description` keyword value for variable
#' properties).
#' @param extras_keywords logical, should the documentation columns specified
#' by `description_extras` be included as separate keywords tethered to the
#' variable's properties? Defaults to `FALSE`, which means that content of such
#' column will be pasted with the description after the `|` separator. Please
#' note that extra keywords in variable are not necassarily compatible with
#' standard JSON Schema syntax without declaration of meta-data dictionaries.
#' For discussion, see:
#' https://json-schema.org/understanding-json-schema/reference/schema#guidelines
#' @param tail_statements an optional character string that specifies additional
#' validation keywords and their values such as
#' [dependent requirements](https://json-schema.org/understanding-json-schema/reference/conditionals#dependentRequired)
#' or [dependent schemas](https://json-schema.org/understanding-json-schema/reference/conditionals#dependentSchemas)
#' @param as_schema logical, should a `schema` class object be returned?
#' See Details.
#' @param ... extra arguments passed to the methods; in case of `data.frame`
#' input those arguments are passed to \code{\link{create_doc}}.
#'
#' @export

  build_schema <- function(x, ...) UseMethod('build_schema')

#' @rdname build_schema
#' @export

  build_schema.documentation <-
    function(x,
             schema_key = "http://json-schema.org/draft-07/schema#",
             id_key = NULL,
             title_key = NULL,
             description_key = NULL,
             description_extras = 'coding',
             extras_keywords = FALSE,
             tail_statements = NULL,
             as_schema = FALSE, ...) {

      ## input control -------

      if(!is_documentation(x)) {

        stop("'x' has to be a 'documentation' class object", call. = FALSE)

      }

      if(!is.null(schema_key)) stopifnot(is.character(schema_key))
      if(!is.null(id_key)) stopifnot(is.character(id_key))
      if(!is.null(title_key)) stopifnot(is.character(title_key))
      if(!is.null(description_key)) stopifnot(is.character(description_key))

      if(is.null(schema_key)) schema_key <- ''
      if(is.null(id_key)) id_key <- ''
      if(is.null(title_key)) title_key <- ''
      if(is.null(description_key)) description_key <- ''

      if(!all(description_extras %in% names(x))) {

        stop(paste("At least one of column names specified by",
                   "'description_extras' is missing from 'x'"),
             call. = FALSE)

      }

      if(!is.null(tail_statements)) {

        if(!is.character(tail_statements)) {

          stop("'tail_statements' needs to be a character string",
               call. = FALSE)

        }

        tail_statements <- tail_statements[1]

      }

      stopifnot(is.logical(extras_keywords))
      stopifnot(is.logical(as_schema))

      ## JSON schema header -----

      header_tbl <-
        tibble(key = c('$schema',
                       '$id',
                       'title',
                       'description',
                       'type'),
               value = c(schema_key,
                         id_key,
                         title_key,
                         description_key,
                         'object'))

      header_str <-
        map2_chr(header_tbl[[1]], header_tbl[[2]],
                 ~paste0('"', .x, '": "', .y, '"'))

      header_str <- paste(header_str, collapse = ', ')

      ## collapsing the description fields -------

      default_keys <- c('variable',
                        'enumeration',
                        'description',
                        'json_expr',
                        'required')

      description_extra <- setdiff(description_extras, default_keys)

      if(length(description_extras) > 0) {

        if(!extras_keywords) {

          for(i in description_extras) {

            x[['description']] <-
              ifelse(x[[i]] == '' | is.na(x[[i]]),
                     x[['description']],
                     paste0(x[['description']],
                            '|', i, ': ', x[[i]]))

          }

        } else {

          for(i in description_extras) {

            x[['json_expr']] <-
              ifelse(x[[i]] == '' | is.na(x[[i]]),
                     x[['json_expr']],
                     paste0(x[['json_expr']],
                            ', "', i, '": "', x[[i]], '"'))

          }

        }

      }

      ## JSON Schema body/properties ----------

      x[['json_expr']] <-
        paste0(x[['json_expr']],
               ', "description": "',
               x[['description']], '"')

      property_str <-
        map2_chr(x[['variable']], x[['json_expr']],
                 ~paste0('"', .x, '": {', .y, '}'))

      property_str <- paste(property_str, collapse = ', ')

      ## specification of possible required variables ---------

      required_str <- ifelse(x[['required']],
                             x[['variable']], NA)

      required_str <- na.omit(required_str)

      required_present <- FALSE

      if(length(required_str) > 0) {

        required_present <- TRUE

        required_str <- map_chr(required_str, ~paste0('"', .x, '"'))

        required_str <- paste(required_str, collapse = ', ')

        required_str <-
          paste0('"required": [', required_str, ']')

      }

      ## stitching the entire JSON string --------

      json_str <-
        paste0(header_str,
               ', "properties": {', property_str, '}')

      if(required_present) {

        json_str <- paste(json_str, required_str, sep = ', ')

      }

      ## optional tail statements -------

      if(!is.null(tail_statements)) {

        json_str <- paste(json_str, tail_statements, sep = ', ')

      }

      ## output ----------

      json_str  <- paste0('{', json_str, '}')

      json_str <- schema_string(json_str)

      if(!as_schema) return(json_str)

      return(string2schema(json_str))

    }

#' @rdname build_schema
#' @export

  build_schema.data.frame <-
    function(x,
             schema_key = "http://json-schema.org/draft-07/schema#",
             id_key = NULL,
             title_key = NULL,
             description_key = NULL,
             description_extras = 'coding',
             extras_keywords = FALSE,
             tail_statements = NULL,
             as_schema = FALSE, ...) {

      ## input controls: most is done by the downstream function ------

      if(!is.data.frame(x)) {

        stop("'x' has to be a data frame", call. = FALSE)

      }

      ## docs object and JSON Schema -------

      docs_obj <- create_doc(x, ...)

      build_schema(docs_obj,
                   schema_key = schema_key,
                   id_key = id_key,
                   title_key = title_key,
                   description_key = description_key,
                   description_extras = description_extras,
                   extras_keywords = extras_keywords,
                   tail_statements = tail_statements,
                   as_schema = as_schema, ...)

    }

# Serialize `schema` objects --------

#' Conversion between `schema` objects with JSON Schemes and JSON strings.
#'
#' @description
#' The functions `string2schema()` and `schema2string()` enable conversion
#' between JSON Schema strings (class \code{\link{schema_string}}) and
#' JSON Schema lists (class \code{\link{schema}}).
#'
#' @return
#' `string2schema()` returns a JSON Schema list (class \code{\link{schema}}),
#' `schema2string()` returns a JSON Schema string (class
#' \code{\link{schema_string}}).
#'
#' @param x a \code{\link{schema}} or \code{\link{schema_string}} object.
#' @param ... additional arguments, currently none.
#'
#' @export

  string2schema <- function(x, ...) {

    ## input control -------

    if(!is_schema_string(x)) {

      stop("'x' has to be a 'schema_string' class object", call. = FALSE)

    }

    ## Schema list -------

    json_lst <- parse_json(x, simplifyVector = TRUE)

    if(!is.null(json_lst$required)) {

      json_lst$required <- as.character(json_lst$required)

    }

    schema(json_lst)

  }

#' @rdname string2schema
#' @export

  schema2string <- function(x, ...) {

    if(!is_schema(x)) {

      stop("'x' has to be a 'schema' JSON Schema list object", call. = FALSE)

    }

    schema_string(toJSON(unclass(x), auto_unbox = TRUE))

  }

# Saving JSON schemas on disc --------

#' Writing JSON Schemas on the disc.
#'
#' @description
#' The `write_schema` methods save JSON Schemas as JSON files on the disc.
#'
#' @return returns invisibly the path to the JSON file.
#'
#' @param x a \code{\link{schema_string}} or \code{\link{schema}} object.
#' @param path a path to the file.
#' @param ... extra arguments passed to the methods.
#'
#' @export

  write_schema <- function(x, path, ...) UseMethod('write_schema')

#' @rdname write_schema
#' @export

  write_schema.schema_string <- function(x, path, ...) {

    if(!is_schema_string(x)) {

      stop("'x' has to be a 'schema_string' object.", call. = FALSE)

    }

    stopifnot(is.character(path))

    if(!stri_detect(path, regex = '\\.json$')) {

      warning("The path specified by 'path' does not refer to a JSON file",
              call. = FALSE)

    }

    write_file(unclass(x), file = path)

    invisible(path)

  }

#' @rdname write_schema
#' @export

  write_schema.schema <- function(x, path, ...) {

    json_str <- schema2string(x)

    write_schema(json_str, path)

  }

# END -----
