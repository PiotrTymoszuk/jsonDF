# Non-exported utilities

# Enumeration tools -------

#' Enumerate elements of a character vector.
#'
#' @description
#' Creates a string with enumerated unique elements of the character vector.
#'
#' @param x a character vector.
#'
#' @return a string with the following numbers of elements and the elements of `x`
#' the `number: element`form.

  character_coding <- function(x) {

    if(!is.character(x)) stop("'x' has to be a character.", call. = FALSE)

    unique_vals <- unique(x)

    paste(seq_along(unique_vals),
          unique_vals,
          sep = ": ",
          collapse = ", ")

  }

#' Create enumeration for a numeric vector.
#'
#'@description
#'This function takes a vector and an enumeration limit.
#' If the vector has fewer unique values than the enumeration limit,
#' the function returns the a string of unique values.
#' Otherwise, it returns \code{NULL}. For factor vectors, the enumeration is
#' always returned.
#'
#' @param x an atomic vector.
#' @param enum_limit an integer representing the enumeration limit.
#'
#' @return A string of unique values separated by commas if the length of
#' unique values is less than the enumeration limit, or `NULL` otherwise.

  enumeration_string <- function(x, enum_limit) {

    ## input control --------

    stopifnot(is.atomic(x))
    stopifnot(is.numeric(enum_limit))

    enum_limit <- as.integer(enum_limit)

    stopifnot(enum_limit > 0)

    if(is.factor(x)) {

      new_x <- as.integer(x)

    } else {

      new_x <- x

    }

    ## enumeration -----

    unique_vals <- sort(unique(new_x))

    if(!is.factor(x)) {

      if(length(unique_vals) > enum_limit) {

        return(NULL)

      }

    }

    if(is.character(x)) {

      unique_vals <- map_chr(unique_vals, ~paste0('"', .x, '"'))

    }

    paste(unique_vals, collapse = ', ')

  }

# JSON data tools --------

#' Generate a JSON string from a row (record) of a data frame.
#'
#' @description
#' Converts a row of a data frame with the given index into a JSON string.
#'
#' @param x a data frame
#' @param idx a row index.
#' @param as_list logical, should JSON data lists be returned?
#' If `as_list = FALSE`, a list of JSON data strings is returned.
#' @param ... arguments passed to \code{\link[jsonlite]{toJSON}}.
#'
#' @return a JSON string generated by \code{\link[jsonlite]{toJSON}}

  row2json <- function(x, idx, as_list = FALSE, ...) {

    ## type control is realized by the upstream exported function

    stopifnot(is.numeric(idx))

    idx <- as.integer(idx)

    if(idx < 0 | idx > nrow(x)) {

      stop("'idx' row index beyond the data range", call. = FALSE)

    }

    ## an uunboxed JSON data string

    json_str <- toJSON(x[idx, , drop = FALSE], ...)

    json_str <-
      stri_replace_all(json_str, regex = '(^\\[)|(\\]$)', replacement = '')

    if(!as_list) return(json_str)

    parse_json(json_str)

  }

# Dates ---------

#' Check if a vector contains dates.
#'
#' @description
#' checks if a vector consists of dates.
#'
#' @param x a vector
#'
#' @return a logical value.

  check_date <- function(x) {

    inherits(x, 'Date') |
      inherits(x, 'POSIXct') |
      inherits(x, 'POSIXt')

  }

# END ------
